---
title: "second"
author: "Owen Wen"
date: "2023-05-21"
output: html_document
---

```{r}
library(GEOquery)
library(dplyr)
library(stringr)
library(sva)
library(Biobase)
library(caret)
library(cvTools)
library(limma)
library(plotly)

set.seed(3888)

# ------------------------------------- BATCH CORRECTION -----------------------
# our primary dataset for binary model
gse26 = getGEO("GSE26578")
gse26 = gse26$GSE26578_series_matrix.txt.gz

# our secondary dataset for batch correction
gse14 = getGEO("GSE14328")
gse14 = gse14$GSE14328_series_matrix.txt.gz

# 411 common genes
length(intersect(fData(gse26)$`Gene`, fData(gse14)$`Gene Symbol`))

# prepping pData for combining
# introduce a new column called graft_status with binary outcomes for gse26
gse26_pData = pData(gse26) %>% 
  mutate(graft_status = case_when(str_detect(pData(gse26)$`disease status:ch1`, fixed("stable")) ~ "stable transplant",
                                  str_detect(pData(gse26)$`disease status:ch1`, fixed("acute")) ~ "acute rejection",
                                  str_detect(pData(gse26)$`disease status:ch1`, fixed("dysfunction")) ~ "acute rejection"))


# manually adding batch
gse26_pData$batch = rep("A", nrow(gse26_pData))
gse26_pData = gse26_pData %>% select(c(geo_accession, graft_status, batch))

# prepping fData data for combining
common_genes = intersect(fData(gse26)$`Gene`, fData(gse14)$`Gene Symbol`)
gse26_index = fData(gse26) %>% filter(`Gene` %in% common_genes)

# for fData, we take only the first uniquely occurring gene - this gives us the 411 common genes 
gse26_unique = gse26_index %>% group_by(`Gene`) %>% slice_head(n = 1)
gse26_fData = gse26_unique %>% mutate(ID = substring(ID, 1, 5))
gse26_fData = gse26_fData %>% select(c(ID, Gene, GB_ACC, GeneDes))
gse26_unique_index = gse26_fData$ID

# prepping exprs for combining
# taking aggregrate of the non-unique gene exprs
gse26_exprs = exprs(gse26) %>% as.data.frame()
gse26_exprs$full_geneID = rownames(gse26_exprs)
gse26_exprs_grouped = gse26_exprs %>% mutate(geneID = substring(full_geneID, 1, 5)) %>% select(-full_geneID)
gse26_exprs_grouped = gse26_exprs_grouped %>% group_by(geneID) %>% summarise_all(mean)
gse26_exprs_grouped = gse26_exprs_grouped %>% filter(geneID %in% gse26_unique_index) %>% as.data.frame()
rownames(gse26_exprs_grouped) = gse26_exprs_grouped$geneID
gse26_exprs_grouped = gse26_exprs_grouped %>% select(-geneID)

# for gse26, fData = gse26_fData, pData = gse26_pData, exprs = gse26_exprs_grouped

# same thing for gse14
# prepping pData for combining
gse14_pData = pData(gse14) %>%
  mutate(graft_status = case_when(str_detect(pData(gse14)$`characteristics_ch1`, fixed("stable")) ~ "stable transplant",
                                  str_detect(pData(gse14)$`characteristics_ch1`, fixed("acute")) ~ "acute rejection"))

# manually adding batch
gse14_pData$batch = rep("B", nrow(gse14_pData))
gse14_pData$geo_accession = rownames(gse14_pData)
gse14_pData = gse14_pData %>% select(c(geo_accession, graft_status, batch))

# prepping fData for combining
gse14_index = fData(gse14) %>% filter(`Gene Symbol` %in% common_genes)

# for fData, we take only the first uniquely occurring gene - this gives us the 411 common genes 
gse14_unique = gse14_index %>% group_by(`Gene Symbol`) %>% slice_head(n = 1)
gse14_fData = gse14_unique %>% select(c(ID, `Gene Symbol`, GB_ACC, `Gene Title`))
gse14_unique_index = gse14_unique$ID

# prepping exprs for combining 
# taking aggregate of the non-unique exprs
gse14_exprs = exprs(gse14) %>% as.data.frame()
gse14_exprs$geneID = rownames(gse14_exprs) 
gse14_exprs = gse14_exprs %>% filter(geneID %in% gse14_unique_index) %>% select(-geneID)

# for gse14, pData = gse14_pData, fData = gse14_fData, exprs = gse14_exprs

# combining
combined_pData = rbind(gse26_pData, gse14_pData)
combined_fData = gse26_fData %>% as.data.frame()
combined_exprs = cbind(gse26_exprs_grouped, gse14_exprs)

# building ExpressionSet object
combined_pData = AnnotatedDataFrame(data = combined_pData)
combined_gse = ExpressionSet(assayData = as.matrix(combined_exprs), phenoData = combined_pData, fData = combined_fData)
fData(combined_gse) = combined_fData

# batch correction
pheno = pData(combined_gse)
edata = exprs(combined_gse)
batch = pheno$batch
mod = model.matrix(~as.factor(graft_status), data = pheno)

# non-parametric adjustment, mean-only version
combat = sva::ComBat(dat = edata, batch = batch, mod = NULL, par.prior = FALSE, mean.only = TRUE)
corrected_gse = ExpressionSet(assayData = as.matrix(combat), phenoData = combined_pData)
fData(corrected_gse) = combined_fData

# removing the one NaN row from exprs
exprs_df = exprs(corrected_gse) %>% as.data.frame()
df_without_na = exprs_df[complete.cases(exprs_df), ]

fData_without_na = filter(fData(corrected_gse), ID != "ZH354")

corrected_gse = ExpressionSet(assayData = as.matrix(df_without_na), phenoData = combined_pData)
fData(corrected_gse) = fData_without_na

# removing a test row from the data for demo
test_row = sample(ncol(pData(corrected_gse)), 1)
test = exprs(corrected_gse)[, test_row] %>% t() %>% as.data.frame()
write.csv(test, "test_binary.csv")

# testing a stable transplant prediction
test_row = which(pData(corrected_gse)$graft_status == "stable transplant")[2]
test = exprs(corrected_gse)[, test_row] %>% t() %>% as.data.frame()
write.csv(test, "test_stable.csv")
# ----------------------------------------- BINARY MODEL -----------------------------------------

folds = 5
repeats = 50

cv_binary = c()
se = c()
sp = c()
balanced_accs = c()

for (i in 1:repeats) {
  cvSets = cvFolds(nrow(pData(gse26)), folds)
  cv_each = c()
  sensitivities = c()
  specificities = c()
  balanced_acc = c()
  
  for (j in 1:folds) {
    test_id = cvSets$subsets[cvSets$which == j]
    X_train = t(exprs(corrected_gse))[-test_id, ]
    X_test = t(exprs(corrected_gse))[test_id, ]
    y_train = corrected_gse$graft_status[-test_id]
    y_test = corrected_gse$graft_status[test_id]
    
    design = model.matrix(~y_train)
    fit = lmFit(t(X_train), design)
    fit = eBayes(fit)
    top = topTable(fit, n = Inf)
    top = top %>% filter(adj.P.Val < 0.05)
    DE_genes = rownames(top)
    
    X_train = X_train[, DE_genes]
    X_test = X_test[, DE_genes]
    
    knn_fit = class::knn(train = X_train, test = X_test, cl = y_train, k = 1)
    cv_each[j] = mean(knn_fit == y_test)
    
    num_positives = sum(knn_fit == "acute rejection")
    num_negatives = sum(knn_fit == "stable transplant")
    
    sensitivities[j] = sum(knn_fit == "acute rejection" & y_test == "acute rejection")/num_positives
    specificities[j] = sum(knn_fit == "stable transplant" & y_test == "stable transplant")/num_negatives
    balanced_acc[j] = (sensitivities[j] + specificities[j])/2
  }
  cv_binary = append(cv_binary, mean(cv_each))
  se = append(se, mean(sensitivities))
  sp = append(sp, mean(specificities))
  balanced_accs = append(balanced_accs, mean(balanced_acc))
}

# store cv accuracies to make boxplots
cv_binary_metrics = cbind(cv_binary, se, sp, balanced_accs)
cv_binary_metrics %>% write.csv("cv_binary_metrics.csv")


# store the model input data
model_data = exprs(corrected_gse) %>% t() %>% as.data.frame()
knn_model = list(train_data = model_data, cl = corrected_gse$graft_status, k = 1)
saveRDS(knn_model, file = "binary_model.rds")

# ------------------------- IFTA SCORE ---------------------------------

gse25 = getGEO("GSE25902")
gse25 = gse25$GSE25902_series_matrix.txt.gz

# finding the top DE genes
ifta = gse25$`i-ifta grade:ch1` %>% as.factor()
design = model.matrix(~0 + ifta)
fit = lmFit(exprs(gse25), design)
fit = eBayes(fit)
tT = topTable(fit, number = Inf)
tT = tT %>% filter(adj.P.Val < 0.05) 
top_genes_ifta = rownames(tT[1:500, ])

# filter exprs to get top 500 genes
gse25_exprs = exprs(gse25) %>% as.data.frame()
gse25_exprs$geneID = rownames(exprs(gse25))
gse25_top500 = gse25_exprs %>% filter(geneID %in% top_genes_ifta)

# format exprs for SVM + CV
training_data = gse25_top500 %>% t() %>% as.data.frame()
training_data = training_data[1:120, ]

# convert all exprs values to numeric
training_data = apply(training_data, 2, as.numeric) %>% as.data.frame()

# removing one row as a demo
test_row = sample(nrow(training_data), 1)
test = training_data[test_row, ]
write.csv(test, "test_ifta.csv")

# normalisation
training_data = log2(training_data + 1)
training_data = apply(training_data, 2, function(x) {
  (x - mean(x))/sd(x)
})
training_data = data.frame(training_data, row.names = row.names(training_data))

training_data$ifta = as.numeric(ifta)

ctrl = trainControl(method = "repeatedcv", number = 5, repeats = 50)
model = train(ifta ~ ., data = training_data, method = "svmRadial", trControl = ctrl)
res = model$resample

model = model$finalModel

# save the model as a .RDS file
saveRDS(model, file = "ifta_model.rds")

# save MAE to a file so we can make boxplot
ifta_acc = data.frame(mae = res$MAE, rmse = res$RMSE, rsquared = res$Rsquared)
ifta_acc %>% write.csv("cv_ifta.csv")

# -------------------------------- CADI SCORE ---------------------------------------

# finding the top DE genes
cadi = gse25$`cadi score:ch1` %>% as.factor()
design = model.matrix(~0 + cadi)
fit = lmFit(exprs(gse25), design)
fit = eBayes(fit)
tT = topTable(fit, number = Inf)
tT = tT %>% filter(adj.P.Val < 0.05) 
top_genes_cadi = rownames(tT[1:500, ])

# filter exprs to get top 500 genes
gse25_exprs = exprs(gse25) %>% as.data.frame()
gse25_exprs$geneID = rownames(exprs(gse25))
gse25_top500 = gse25_exprs %>% filter(geneID %in% top_genes_cadi)

# format exprs for SVM + CV
training_data = gse25_top500 %>% t() %>% as.data.frame()
training_data = training_data[1:120, ]

# convert all exprs values to numeric
training_data = apply(training_data, 2, as.numeric) %>% as.data.frame()


# removing one row as a demo
test_row = sample(nrow(training_data), 1)
test = training_data[test_row, ]
write.csv(test, "test_cadi.csv")

# normalisation
training_data = log2(training_data + 1)
training_data = apply(training_data, 2, function(x) {
  (x - mean(x))/sd(x)
})
training_data = data.frame(training_data, row.names = row.names(training_data))

training_data$cadi = as.numeric(cadi)


ctrl = trainControl(method = "repeatedcv", number = 5, repeats = 50)
model = train(cadi ~ ., data = training_data, method = "svmRadial", trControl = ctrl)
res = model$resample

model = model$finalModel

# save the model as a .RDS file
saveRDS(model, file = "cadi_model.rds")

# save MAE to a file so we can make boxplot
cadi_acc = data.frame(mae = res$MAE, rmse = res$RMSE, rsquared = res$Rsquared)
cadi_acc %>% write.csv("cv_cadi.csv")

# ------------------------- LIST OF GENES NEEDED FOR PREDICTION -----------------------

binary_genes = fData(corrected_gse)
ifta_genes = fData(gse25) %>% filter(ID %in% top_genes_ifta)
cadi_genes = fData(gse25) %>% filter(ID %in% top_genes_cadi)

ifta_genes = ifta_genes %>% select(c(`ID`, `Gene Symbol`, `GB_ACC`, `Gene Ontology Molecular Function`)) %>% 
  rename(Gene = `Gene Symbol`, GeneDes = `Gene Ontology Molecular Function`)

cadi_genes = cadi_genes %>% select(c(ID, `Gene Symbol`, GB_ACC, `Gene Ontology Molecular Function`)) %>% 
  rename(Gene  = `Gene Symbol`, GeneDes = `Gene Ontology Molecular Function`)

binary_genes %>% write.csv("binary_genes.csv")
cadi_genes %>% write.csv("cadi_genes.csv")
ifta_genes %>% write.csv("ifta_genes.csv")

# --------------------------- PCA FOR BATCH CORRECTION -------------------------------------

before_pca = prcomp(t(exprs(combined_gse)))
before_toplot = data.frame(combined_gse$batch, pc1 = before_pca$x[, 1], pc2 = before_pca$x[, 2])
ggplot(before_toplot, aes(x = pc1, y = pc2, color = combined_gse$batch)) + geom_point(size = 3, shape = 18) + theme_minimal() +
  labs(x = "PC1", y = "PC2") + scale_color_discrete(name = "Batch") + theme(text = element_text(size = 20))

after_pca = prcomp(t(exprs(corrected_gse)))
after_toplot = data.frame(corrected_gse$batch, pc1 = after_pca$x[, 1], pc2 = after_pca$x[, 2])
ggplot(after_toplot, aes(x = pc1, y = pc2, color = corrected_gse$batch)) + geom_point(size = 3, shape = 18) + theme_minimal() +
  labs(x = "PC1", y = "PC2") + scale_color_discrete(name = "Batch") + theme(text = element_text(size = 20))

# --------------------------- ROBUSTNESS TEST -----------------------------------------------

gse36 = getGEO("GSE36059")
gse36 = gse36$GSE36059_series_matrix.txt.gz

# remove nephrectomies because that's not relevant
removed = which(pData(gse36)$`diagnosis (tcmr,abmr,mixed,non-rejecting):ch1` != "Nephrectomy")
filtered_pData = pData(gse36)[removed, ]
filtered_exprs = exprs(gse36) %>% as.data.frame()
filtered_exprs = filtered_exprs[, removed]

filtered_pData = AnnotatedDataFrame(data = filtered_pData)
filtered_gse = ExpressionSet(assayData = as.matrix(filtered_exprs), phenoData = filtered_pData)
fData(filtered_gse) = fData(gse36)

pData(filtered_gse) = pData(filtered_gse) %>% 
  mutate(graft_status = case_when(pData(filtered_gse)$`diagnosis (tcmr,abmr,mixed,non-rejecting):ch1` == "non-rejecting" ~ "stable transplant",
                                  pData(filtered_gse)$`diagnosis (tcmr,abmr,mixed,non-rejecting):ch1` == "ABMR" ~ "acute rejection",
                                  pData(filtered_gse)$`diagnosis (tcmr,abmr,mixed,non-rejecting):ch1` == "TCMR" ~ "acute rejection", 
                                  pData(filtered_gse)$`diagnosis (tcmr,abmr,mixed,non-rejecting):ch1` == "MIXED" ~ "acute rejection"))

# finding the top DE genes
design = model.matrix(~0 + pData(filtered_gse)$graft_status)
fit = lmFit(exprs(filtered_gse), design)
fit = eBayes(fit)
tT = topTable(fit, number = Inf)
tT = tT %>% filter(adj.P.Val < 0.05) 
top_genes_gse36 = rownames(tT[1:410, ])

common_genes_gse36 = fData(filtered_gse) %>% filter(ID %in% top_genes_gse36)

# only 7 common genes
intersect(common_genes_gse36$`Gene Symbol`, binary_genes$Gene)

robust_test = exprs(filtered_gse) %>% as.data.frame()
robust_test$ID = rownames(robust_test)
robust_test = robust_test %>% filter(ID %in% top_genes_gse36) %>% select(-ID) %>% t()
robust_output = class::knn(train = knn_model$train_data, test = robust_test, cl = knn_model$cl, k = knn_model$k)

robust_acc = mean(robust_output == filtered_gse$graft_status)

num_positives = sum(robust_output == "acute rejection")
num_negatives = sum(robust_output == "stable transplant")

sens = sum(robust_output == "acute rejection" & filtered_gse$graft_status == "acute rejection")/num_positives
spec = sum(robust_output == "stable transplant" & filtered_gse$graft_status == "stable transplant")/num_negatives
balanced_acc_robust = (sens + spec)/2

```



```{r}
calc_cv_acc <- function(X, y, cvK, n_sim) {
  cv_acc_knn <- array(0, dim = c(n_sim, 50))
  cv_ba_knn <- array(0, dim = c(n_sim, 50))  # for balanced accuracy

  for (i in 1:n_sim) {
    cvSets <- cvTools::cvFolds(nrow(X), cvK)
    cv_acc <- matrix(0, nrow = cvK, ncol = 50)
    cv_ba <- matrix(0, nrow = cvK, ncol = 50)  # for balanced accuracy

    for (j in 1:cvK) {
      test_id <- cvSets$subsets[cvSets$which == j]
      X_test <- X[test_id, ]
      X_train <- X[-test_id, ]
      y_test <- y[test_id]
      y_train <- y[-test_id]
      
      design = model.matrix(~y_train)
      fit = lmFit(t(X_train), design)
      fit = eBayes(fit)
      top = topTable(fit, n = Inf)
      top = top %>% filter(adj.P.Val < 0.05)
      DE_genes = rownames(top)
      
      X_train = X_train[, DE_genes]
      X_test = X_test[, DE_genes]

      for (kn in 1:50) {
        fit = class::knn(train = X_train, test = X_test, cl = y_train, k = kn)
        cv_acc[j, kn] <- mean(fit == y_test)
        
        num_positives = sum(fit == "acute rejection")
        num_negatives = sum(fit == "stable transplant")
    
        sensitivity = sum(fit == "acute rejection" & y_test == "acute rejection")/num_positives
        specificity = sum(fit == "stable transplant" & y_test == "stable transplant")/num_negatives
        balanced_acc = (sensitivity + specificity)/2

        cv_ba[j, kn] <- balanced_acc
      }
    }
    cv_acc_knn[i, ] <- colMeans(cv_acc)  # take mean across folds
    cv_ba_knn[i, ] <- colMeans(cv_ba)  # take mean across folds for balanced accuracy
  }

  list(acc = cv_acc_knn, ba = cv_ba_knn)  # return both accuracy and balanced accuracy arrays
}


```



```{r}
# First, let's assume you have some data X and labels y, number of folds cvK and number of simulations n_sim
X <- t(exprs(corrected_gse))
y <- corrected_gse$graft_status
# cvK <- ...
# n_sim <- ...

# Run the calc_cv_acc function
result <- calc_cv_acc(X, y, folds, repeats)

acc_df <- as.data.frame(result$acc)
names(acc_df) <- paste("k =", 1:50)

ba_df <- as.data.frame(result$ba)
names(ba_df) <- paste("k =", 1:50)

# Convert data from wide to long format
acc_long <- reshape2::melt(acc_df)
ba_long <- reshape2::melt(ba_df)

# Generate boxplot for accuracy
p_acc <- ggplot(acc_long, aes(x = variable, y = value)) + 
  geom_boxplot() +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(x = "k", y = "Accuracy", title = "Accuracy for different k")

# Generate boxplot for balanced accuracy
p_ba <- ggplot(ba_long, aes(x = variable, y = value)) + 
  geom_boxplot() +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(x = "k", y = "Balanced Accuracy", title = "Balanced Accuracy for different k")

# Convert ggplot to ggplotly

```






```{r}
library(rsconnect)
library(shiny)
library(bslib)
library(shinydashboard)
library(GEOquery)
library(dplyr)
library(caret)
library(kernlab)

ui = dashboardPage(
  dashboardHeader(title = "NephroPulse"),

  
  dashboardSidebar(
    
    sidebarMenu(
      menuItem("Dashboard", tabName = "dashboard", icon = icon("home")),
      menuItem("Short-term rejection", tabName = "binary", icon = icon("notes-medical")),
      menuItem("CADI score", tabName = "cadi", icon = icon("notes-medical")),
      menuItem("i-IFTA score", tabName = "ifta", icon = icon("notes-medical")),
      menuItem("Our Prediction Model", tabName = "info", icon = icon("info-circle"))
    )
  ),
  
  dashboardBody(
    tags$head(
      tags$link(rel = "stylesheet", type = "text/css", href = "customtitle.css")
    ),
    
    tags$head(tags$style(HTML("
                              .bold-text {
                                font-weight: bold;
                              }"
                              ))),
    
    tabItems(
      tabItem(tabName = "dashboard",
              h1("Dashboard"),
              br(),
              p("Welcome to the Kidney Transplantation Risk Calculator!"),
              p("This app helps you predict the risk of kidney transplantation for individual patients. 
                To use the app, you will need to upload a CSV file containing patient data."),
              p("Once the data has been uploaded, the app will automaticaly predict the risk for that patient. Please note that the app can predict risk for only one patient at a time. Details of the structure of the .csv file required are provided in each tab."),
              p("For more information about the model, please visit the 'Our Prediction Model' tab."),
              br(),
              h3("Quick Summary of Features"),
              fluidRow(column(4,
                              h4("Short-term rejection"),
                              p("Our model classifies the kidney transplant as experiencing acute rejection or short-term stability based on 
                                patient gene expression profiles.")),
                       column(4,
                              h4("CADI score"),
                              p("The Chronic Allograft Damage Index (CADI) provides a measure of chronic damage that the kidney is experiencing and 
                                can help assess long-term graft survival.")),
                       column(4,
                              h4("i-IFTA score"),
                              p("The Interstitial Fibrosis and Tubular Atrophy (i-IFTA) score is a measure of inflammation or scarring in the kidney."))),
              br(),
              p("Each of our models requires a different set of genes to perform the prediction, the details of which are provided within .csv files wihtin each tab.
                Please ensure that your .csv patient file contains one row representing the patient, with the columns representing the gene expression values.
                You can find a sample patient file below."),
              downloadLink("sample_patient", "Sample Patient File")),
      tabItem(tabName = "binary",
              h1("Short-term rejection"),
              fluidRow(box(status = "primary", fileInput("binary_file", "Choose .csv file", accept = ".csv"))),
              p("Your gene expression profile is most consistent with:"),
              fluidRow(box(tags$div(style = "text-align: center;
                                           font-size: 18px;
                                           font-weight:bold", textOutput("binary_outcome")))),
              br(),
              p(class = "bold-text", "What does your prediction mean?"),
              fluidRow(column(width = 5, 
                           HTML("<p><b><i>Acute rejection</b></i> is a condition where the transplanted organ is
                           recognized as a 'foreign' entity and gets rejected by the immune system. This can
                                occur anytime between one week after the transplantation to 3 months after the
                                transplantation, and is a normal immune response.")),
                       column(width = 5,
                              HTML("<p>If the condition of the transplant is <b><i>stable</i></b>, it is not being
                                   actively rejected by the immune system."))),
              br(),
              p("You can find information on the genes required for this prediction below."),
              downloadLink("binary_download", "Download CSV"),
              br(),
              p("You can also find a template file below."),
              downloadLink("column_names_binary", "Download CSV")),
      tabItem(tabName = "cadi",
              h1("CADI score"),
              fluidRow(box(status = "primary", fileInput("cadi_file", "Choose .csv file", accept = ".csv"))),
              p("You predicted Chronic Allograft Damage Index is:"),
              fluidRow(box(tags$div(style = "text-align: center;
                                    font-size: 18px;
                                    font-weight: bold", textOutput("cadi_outcome")))),
              br(),
              HTML("<p>The <b>Chronic Allograft Damage Index</b>, or <b>CADI score</b>, provides a measure of 
                   chronic damage to the kidney and is closely correlated with later graft function and outcome.
                   The score ranges from a minimum of 0 to a maximum of 18, with a higher score corresponding to
                   a less favourable outcome for allograft status. It is calculated as a sum of
                   six histopathological parameters:"),
              HTML("<ul>
                      <li>interstitial inflammation</li>
                      <li>tubular atrophy</li>
                      <li>interstitial fibrosis</li>
                      <li>arterial fibrointimal thickening</li>
                      <li>glomerular mesangial matrix increase</li>
                      <li>percentage of globally sclerosed glomeruli</li>
                   </ul>"),
              br(),
              p("You can find information on the genes required for this prediction below."),
              downloadLink("cadi_download", "Download CSV"),
              br(),
              p("You can also find a template file below."),
              downloadLink("column_names_cadi", "Download CSV"),
              HTML("<p><b><i>Please note, this prediction is supplementary to our main short-term rejection prediction, and must be used in
                   conjunction with it.</i></b></p>")),
      tabItem(tabName = "ifta",
              h1("i-IFTA score"),
              fluidRow(box(status = "primary", fileInput("ifta_file", "Choose .csv file", accept = ".csv"))),
              fluidRow(box(tags$div(style = "text-align: center;
                                    font-size: 18px;
                                    font-weight: bold", textOutput("ifta_outcome")))),
              br(),
              HTML("<p>The <b>I-IFTA</b> score is a measure of inflammation in the kidney and has been associated
                   with decreased allograft survival. The score ranges from a minimum of 0 to a maximum of 3."),
              HTML("<ul>
                      <li><b>0: </b>no inflammation</li>
                      <li><b>1: </b>mild inflammation</li>
                      <li><b>2: </b>moderate inflammation</li>
                      <li><b>3: </b>severe inflammation</li
                   </ul>"),
              br(),
              p("You can find information on the genes required for this prediction below."),
              downloadLink("ifta_download", "Download CSV"),
              br(),
              p("You can also find a template file below."),
              downloadLink("column_names_ifta", "Download CSV"),
              HTML("<p><b><i>Please note, this prediction is supplementary to our main short-term rejection prediction, and must be used in
                   conjunction with it.</i></b></p>")),
      tabItem(tabName = "info",
  h1("Our Prediction Model"),
  tabsetPanel(
    tabPanel("Short-term Rejection Model", 
      h2("Short-term rejection model"),
      tabsetPanel(
        tabPanel("Selection of k", 
                 plotlyOutput("k_selection_cv"),
                 plotlyOutput("k_selection_ba"),
          HTML("<p>The model employs k-Nearest Neighbors (kNN) classification, al algorithm that works by classifying a data point based on the majority class of its 'k' nearest neighbors. The optimal 'k' of 1 for our case was determined based on specific characteristics of the data and the model's performance.")),
        tabPanel("Balanced Accuracy & cross validation", 
                 plotlyOutput("cv_binary_boxplot"),
          HTML("<p>To validate the model's performance and generalize it to unseen data, it uses cross-validation (CV) with 5 folds and 50 repeats. This resampling procedure involves dividing the data into 5 subsets (folds). For each 
repetition, the model is trained on 4 subsets and tested on the remaining one. This process is repeated 50 
times, with each fold used as the testing set 10 times over the 50 repetitions.")),
        tabPanel("Sensitivity",  
                 plotlyOutput("sensitivity_binary"),
          HTML("<p>The ability of a model to correctly predict that a patient's kidney is experiencing acute rejection, given that the patient is actually experiencing acute rejection. For our model, this measure was 0.96, which means that 96% of the time, the model can correctly identify patients experiencing acute rejection.")),
        tabPanel("Specificity",  
                 plotlyOutput("specificity_binary"),
          HTML("<p>The ability of a model to correctly predict that a patient's kidney is stable, given that the patient's kidney is actually stable. For our model, this measure was 0.97, which means that 97% of the time, the model can correctly identify patients with stable kidneys."))
      )
    ),
    tabPanel("CADI Score Model", 
      h2("CADI score cross validation"),
      tabsetPanel(
        tabPanel("General", 
          HTML("<p>To ensure the model's robustness and assess its performance, cross-validation (CV) with 5 folds and 50 repeats is used. In this process, the dataset is partitioned into 5 subsets. The model is then trained on 4 of 
these subsets, and the remaining subset is used for testing. This is done 50 times, each with a different testing subset, hence 50 repeats.")),
        tabPanel("Mean Absolute Error (MAE)",   
                 plotlyOutput("cadi_mae_plot"),
          HTML("<p>The average difference between the model's predicted CADI score andthe actual score. For our model, this measure was 2.21, which means that the predicted CADI score differs from the actual score by 2.21 points on average. This is the most straightforward measure of our model's accuracy")),
        tabPanel("Root Mean Square Error (RMSE)",    
                 plotlyOutput("cadi_rmse_plot"),
          HTML("<p>A measure of error similar to MAE, but it penalises bigger differences between the model's predicted value and the actual value. For our model, this measure was 2.56.")),
        tabPanel("R Squared",    
                 plotlyOutput("cadi_rsquared_plot"),
          HTML("<p>A measure of how well our model emulates the relationship between gene expression levels and the CADI score. The value ranges from 0 to 1, and the closer the value is to 1, the better the model
can perform. For our model, this value was 0.36."))
      )
    ),
    tabPanel("i-IFTA Score Model",
      h2("i-IFTA score cross validation"),
      tabsetPanel(
        tabPanel("General", 
          HTML("<p>To ensure the model's robustness and assess its performance, cross-validation (CV) with 5 folds and 50 repeats is used. In this process, the dataset is partitioned into 5 subsets. The model is then trained on 4 of 
these subsets, and the remaining subset is used for testing. This is done 50 times, each with a different testing subset, hence 50 repeats.")),
        tabPanel("Mean Absolute Error (MAE)", 
                 plotlyOutput("ifta_mae_plot"),
          HTML("<p>The average difference between the model's predicted i-IFTA score and the actual score. For our model, this measure was 0.68, which means that the predicted CADI score differs from the actual score by 0.68 points on average. This is the most straightforward measure of our model's accuracy.")),
        tabPanel("Root Mean Square Error (RMSE)", 
                 plotlyOutput("ifta_rmse_plot"),
          HTML("<p>A measure of error similar to MAE, but it penalises bigger differences between the model's predicted value and the actual value. For our model, this measure was 0.9.")),
        tabPanel("R Squared", 
                 plotlyOutput("ifta_rsquared_plot"),
          HTML("<p>A measure of how well our model emulates the relationship between gene expression levels and
the i-IFTA score. The value ranges from 0 to 1, and the closer the value is to 1, the better the model can perform. For our model, this value was 0.21."))
      )
    ),
  tabPanel("Resource", 
          h2("Additional Resources"),
              HTML("<p>The datasets used to train this model were all obtained from the <a href='https://www.ncbi.nlm.nih.gov/gds/'>Gene Expression Omnibus database</a>.</p>"),
              HTML("<p>Two datasets were used to train the short-term rejection model: <a href='https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE26578'>GSE26578</a> and <a href='https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE14328'>GSE14328</a>.</p>"),
              HTML("<p>For both the CADI and IFTA models, <a href='https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE25902'>GSE25902</a> was used.</p>")
        )
  )
)


    
  )
)
)


server = function(input, output) {
  binary_model = readRDS("binary_model.rds")
  ifta_model = readRDS("ifta_model.rds")
  cadi_model = readRDS("cadi_model.rds")
  
  cv_binary_metrics = read.csv("cv_binary_metrics.csv")
  cv_cadi = read.csv("cv_cadi.csv")
  cv_ifta = read.csv("cv_ifta.csv")
  
  output$binary_outcome = renderText({
    if (is.null(input$binary_file)) {
      return("Please upload a .csv file to see results.")
    }
    
    file_path = input$binary_file$datapath
    testing_data = read.csv(file_path)
    testing_data = testing_data[, 2:411]
    
    out = class::knn(train = binary_model$train_data, test = testing_data, cl = binary_model$cl, k = binary_model$k)
    
    paste(out)
  })
  
  output$ifta_outcome = renderText({
    if (is.null(input$ifta_file)) {
      return("Please upload a .csv file to see results.")
    }
    
    file_path = input$ifta_file$datapath
    testing_data = read.csv(file_path)
    testing_data = testing_data[, 2:501]
    
    out = round(predict(ifta_model, testing_data)[1])
    
    paste(out)
  })
  
  output$cadi_outcome = renderText({
    if (is.null(input$cadi_file)) {
      return("Please upload a .csv file to see results.")
    }
    
    file_path = input$cadi_file$datapath
    testing_data = read.csv(file_path)
    testing_data = testing_data[, 2:501]
    
    out = round(predict(cadi_model, testing_data)[1])
    
    paste(out)
  })
  
  output$binary_download = downloadHandler(
    filename = function() {
      paste("binary_genes.csv", sep = "")
    },
    content = function(binary_genes) {
      file.copy("binary_genes.csv", binary_genes)
    })
  
  output$sample_patient = downloadHandler(
    filename = function() {
      paste("test_binary.csv", sep = "")
    },
    content = function(sample_patient_file) {
      file.copy("test_binary.csv", sample_patient_file)
    })
  
  output$cadi_download = downloadHandler(
    filename = function() {
      paste("cadi_genes.csv", sep = "")
    },
    content = function(cadi_genes) {
      file.copy("cadi_genes.csv", cadi_genes)
    })
  
  output$ifta_download = downloadHandler(
    filename = function() {
      paste("ifta_genes.csv", sep = "")
    },
    content = function(ifta_genes) {
      file.copy("ifta_genes.csv", ifta_genes)
    })
  
  output$cv_binary_boxplot <- renderPlotly({
  tryCatch({
    cv_binary_metrics_df <- as.data.frame(cv_binary_metrics)  # convert matrix to data frame
    cv_binary_metrics_df$id <- rownames(cv_binary_metrics_df)  # add an id column

    long = cv_binary_metrics_df %>%
    select(c(id, cv_binary, balanced_accs)) %>%
    reshape2::melt(id.vars = "id")

    p = ggplot(long, aes(y = value)) + geom_boxplot() +
    facet_grid(~ variable, labeller = labeller(variable = c(cv_binary = "Cross Validation Accuracy", balanced_accs = "Balanced Accuracy"))) + xlab("") + 
    ylab("Accuracy") + ggtitle("Short-term rejection prediction") + theme(plot.title = element_text(hjust = 0.5)) +
      scale_x_discrete(labels = c()) + theme_bw() + theme(text = element_text(size = 17))
    plotly::ggplotly(p)
  }, error = function(e) {
    print(as.character(e$message))
  })
})
  
  output$k_selection_cv <- renderPlotly({
    plotly::ggplotly(p_acc)
  })
  
  output$k_selection_ba <- renderPlotly({
    plotly::ggplotly(p_ba)
  })
  
  output$sensitivity_binary <- renderPlotly({
  tryCatch({
    cv_binary_metrics_df <- as.data.frame(cv_binary_metrics)  # convert matrix to data frame
    cv_binary_metrics_df$id <- rownames(cv_binary_metrics_df)  # add an id column

    long = cv_binary_metrics_df %>%
    select(c(id, se)) %>%
    reshape2::melt(id.vars = "id")

    p = ggplot(long, aes(y = value)) + geom_boxplot() +
    facet_grid(~ variable, labeller = labeller(variable = c(se = "Sensitivity"))) + xlab("") + 
    ylab("Accuracy") + ggtitle("Short-term rejection Sensitivity") + theme(plot.title = element_text(hjust = 0.5)) +
      scale_x_discrete(labels = c()) + theme_bw() + theme(text = element_text(size = 17))
    plotly::ggplotly(p)
  }, error = function(e) {
    print(as.character(e$message))
  })
})

output$specificity_binary <- renderPlotly({
  tryCatch({
    cv_binary_metrics_df <- as.data.frame(cv_binary_metrics)  # convert matrix to data frame
    cv_binary_metrics_df$id <- rownames(cv_binary_metrics_df)  # add an id column

    long = cv_binary_metrics_df %>%
    select(c(id, sp)) %>%
    reshape2::melt(id.vars = "id")

    p = ggplot(long, aes(y = value)) + geom_boxplot() +
    facet_grid(~ variable, labeller = labeller(variable = c(sp = "Specificity"))) + xlab("") + 
    ylab("Accuracy") + ggtitle("Short-term rejection Specificity") + theme(plot.title = element_text(hjust = 0.5)) +
      scale_x_discrete(labels = c()) + theme_bw() + theme(text = element_text(size = 17))
    plotly::ggplotly(p)
  }, error = function(e) {
    print(as.character(e$message))
  })
})

  
 output$cadi_mae_plot = renderPlotly({
  long = cv_cadi %>% select(X, mae) %>% as.data.frame() %>% reshape2::melt(id.vars = "X")
  p = ggplot(long, aes(y = value)) + geom_boxplot() +
    ggtitle("CADI Mean Absolute Error") + 
    theme(plot.title = element_text(hjust = 0.5)) + theme_bw() + theme(text = element_text(size = 17))
  plotly::ggplotly(p)
})

output$cadi_rmse_plot = renderPlotly({
  long = cv_cadi %>% select(X, rmse) %>% as.data.frame() %>% reshape2::melt(id.vars = "X")
  p = ggplot(long, aes(y = value)) + geom_boxplot() +
    ggtitle("CADI Root Mean Squared Error") + 
    theme(plot.title = element_text(hjust = 0.5)) + theme_bw() + theme(text = element_text(size = 17))
  plotly::ggplotly(p)
})

output$cadi_rsquared_plot = renderPlotly({
  long = cv_cadi %>% select(X, rsquared) %>% as.data.frame() %>% reshape2::melt(id.vars = "X")
  p = ggplot(long, aes(y = value)) + geom_boxplot() +
    ggtitle("CADI R Squared over") + 
    theme(plot.title = element_text(hjust = 0.5)) + theme_bw() + theme(text = element_text(size = 17))
  plotly::ggplotly(p)
})

output$ifta_mae_plot = renderPlotly({
  long = cv_ifta %>% select(X, mae) %>% as.data.frame() %>% reshape2::melt(id.vars = "X")
  p = ggplot(long, aes(y = value)) + geom_boxplot() +
    ggtitle("i-IFTA Mean Absolute Error") + 
    theme(plot.title = element_text(hjust = 0.5)) + theme_bw() + theme(text = element_text(size = 17))
  plotly::ggplotly(p)
})

output$ifta_rmse_plot = renderPlotly({
  long = cv_ifta %>% select(X, rmse) %>% as.data.frame() %>% reshape2::melt(id.vars = "X")
  p = ggplot(long, aes(y = value)) + geom_boxplot() +
    ggtitle("i-IFTA Root Mean Squared Error") + 
    theme(plot.title = element_text(hjust = 0.5)) + theme_bw() + theme(text = element_text(size = 17))
  plotly::ggplotly(p)
})

output$ifta_rsquared_plot = renderPlotly({
  long = cv_ifta %>% select(X, rsquared) %>% as.data.frame() %>% reshape2::melt(id.vars = "X")
  p = ggplot(long, aes(y = value)) + geom_boxplot() +
    ggtitle("i-IFTA R Squared") + 
    theme(plot.title = element_text(hjust = 0.5)) + theme_bw() + theme(text = element_text(size = 17))
  plotly::ggplotly(p)
})

  
  output$column_names_binary = downloadHandler(
    filename = function() {
      paste("column_names.csv", sep = "")
    },
    content = function(column_names_binary) {
      file.copy("column_names_binary", column_names_binary)
    })
  
  output$column_names_cadi = downloadHandler(
    filename = function() {
      paste("column_names_cadi.csv", sep = "")
    },
    content = function(column_names_cadi) {
      file.copy("column_names_cadi", column_names_cadi)
    })
  
  output$column_names_ifta = downloadHandler(
    filename = function() {
      paste("column_names_ifta.csv", sep = "")
    },
    content = function(column_names_ifta) {
      file.copy("column_names_ifta", column_names_ifta)
    })
}
shinyApp(ui = ui, server = server)
```

